#!/usr/bin/env python3
"""
Rebuild vsme-data-model-spec.json by auto-extracting all Named Ranges from the
Excel template and distributing them into modules based on sheet â†’ module
heuristics. This is a stopgap to get all ~797 datapoints represented until a
curated model is available.
"""
import json
import re
from pathlib import Path
from typing import Dict, List, Tuple

try:
    import openpyxl  # type: ignore
except ImportError:  # pragma: no cover - helper install for local runs
    import subprocess, sys

    subprocess.check_call([sys.executable, "-m", "pip", "install", "openpyxl"])
    import openpyxl  # type: ignore


ROOT = Path(__file__).resolve().parents[1]
EXCEL_PATH = ROOT / "VSME-Digital-Template-1.1.0.xlsx"
SPEC_PATH = ROOT / "docs" / "data-model" / "vsme-data-model-spec.json"

# Map Excel sheets to module codes (heuristic, based on template structure)
SHEET_TO_MODULES: Dict[str, List[str]] = {
    "General Information": ["B1", "B2", "C1", "C2"],
    "Environmental Disclosures": ["B3", "B4", "B5", "B6", "B7", "C3", "C4"],
    "Social Disclosures": ["B8", "B9", "B10", "C5", "C6", "C7"],
    "Governance Disclosures": ["B11", "C8", "C9"],
}


def camel_case(name: str) -> str:
    """Convert Named Range to lowerCamelCase datapointId."""
    # Replace separators with spaces, then camel-case
    cleaned = re.sub(r"[^a-zA-Z0-9]+", " ", name)
    parts = [p for p in cleaned.strip().split(" ") if p]
    if not parts:
        return name
    first = parts[0].lower()
    rest = [p.capitalize() for p in parts[1:]]
    candidate = first + "".join(rest)
    # Ensure it starts with a letter for TS friendliness
    if not candidate[0].isalpha():
        candidate = f"f{candidate}"
    return candidate


def guess_data_type(name: str) -> str:
    """Lightweight heuristic to guess a data type from the Named Range name."""
    lower = name.lower()
    if any(k in lower for k in ["date", "day", "month", "year"]):
        return "date"
    if any(k in lower for k in ["percent", "percentage", "rate", "ratio", "intensity"]):
        return "number"
    if any(k in lower for k in ["total", "sum", "amount", "revenue", "turnover", "emission", "consumption", "waste", "hours", "employees", "number", "count", "volume", "quantity"]):
        return "number"
    if any(lower.startswith(prefix) for prefix in ["is", "has", "include", "exclude"]):
        return "boolean"
    if any(k in lower for k in ["yesno", "flag", "boolean"]):
        return "boolean"
    if "url" in lower:
        return "url"
    if "email" in lower:
        return "email"
    return "text"


def extract_named_ranges() -> Dict[str, Dict[str, str]]:
    """Extract Named Ranges from Excel."""
    wb = openpyxl.load_workbook(EXCEL_PATH, data_only=True)
    named_ranges: Dict[str, Dict[str, str]] = {}
    for name_str, definition in wb.defined_names.items():
        destinations = list(definition.destinations)
        if not destinations:
            continue
        sheet_name, cell_ref = destinations[0]
        named_ranges[name_str] = {
            "name": name_str,
            "reference": f"'{sheet_name}'!{cell_ref}",
            "sheet": sheet_name,
            "cellRef": cell_ref,
        }
    wb.close()
    return named_ranges


def load_spec() -> Dict:
    if not SPEC_PATH.exists():
        raise SystemExit(f"Spec file not found: {SPEC_PATH}")
    return json.loads(SPEC_PATH.read_text())


def ensure_module_map(spec: Dict) -> Dict[str, Dict]:
    modules = {}
    for group in ("basicModules", "comprehensiveModules"):
        for module in spec.get("coreReport", {}).get(group, []):
            modules[module["moduleCode"]] = module
            module.setdefault("disclosures", [])
    return modules


def get_or_create_disclosure(module: Dict) -> Dict:
    """Use/ensure a single autogenerated disclosure container."""
    if module.get("disclosures"):
        # Reuse first disclosure to avoid exploding the structure
        return module["disclosures"][0]
    disclosure = {
        "disclosureId": "autoGenerated",
        "disclosureName": "Auto-generated from Named Ranges",
        "datapoints": [],
    }
    module["disclosures"].append(disclosure)
    return disclosure


def assign_module(sheet: str) -> str:
    for key, modules in SHEET_TO_MODULES.items():
        if sheet == key:
            return modules[0]
    # Fallback bucket
    return "UNMAPPED"


def rebuild() -> Tuple[Dict, int]:
    spec = load_spec()
    named_ranges = extract_named_ranges()

    # Preserve existing namedRanges block for reference
    spec["namedRanges"] = named_ranges

    modules = ensure_module_map(spec)
    # Add fallback module if needed
    if "UNMAPPED" not in modules:
        modules["UNMAPPED"] = {
            "moduleId": "unmapped",
            "moduleCode": "UNMAPPED",
            "moduleName": "Unmapped Named Ranges",
            "moduleType": "aux",
            "sheet": "N/A",
            "disclosures": [],
        }
        spec.setdefault("coreReport", {}).setdefault("basicModules", []).append(
            modules["UNMAPPED"]
        )

    existing_ids = set()
    for module in modules.values():
        for disclosure in module.get("disclosures", []):
            for dp in disclosure.get("datapoints", []):
                existing_ids.add(dp["datapointId"])

    added = 0
    for range_name, info in named_ranges.items():
        dp_id = camel_case(range_name)
        if dp_id in existing_ids:
            continue
        data_type = guess_data_type(range_name)
        target_module_code = assign_module(info.get("sheet", ""))
        module = modules.get(target_module_code, modules["UNMAPPED"])
        disclosure = get_or_create_disclosure(module)
        disclosure.setdefault("datapoints", []).append(
            {
                "datapointId": dp_id,
                "label": {
                    "en": range_name,
                    "de": range_name,
                },
                "dataType": data_type,
                "required": False,
                "excelNamedRange": range_name,
                "excelReference": info.get("reference"),
            }
        )
        existing_ids.add(dp_id)
        added += 1

    # Write updated spec
    SPEC_PATH.write_text(json.dumps(spec, indent=2, ensure_ascii=False))
    return spec, added


def main() -> int:
    spec, added = rebuild()
    total = sum(
        len(d.get("datapoints", []))
        for group in ("basicModules", "comprehensiveModules")
        for m in spec.get("coreReport", {}).get(group, [])
        for d in m.get("disclosures", [])
    )
    print(f"Added {added} datapoints. Total datapoints now: {total}")
    print(f"Spec updated at {SPEC_PATH}")
    return 0


if __name__ == "__main__":
    raise SystemExit(main())
